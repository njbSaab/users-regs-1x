# Предложение по оркестрации двух медленных запросов после верификации

## Текущая проблема

На текущий момент после успешной верификации кода, клиент должен выполнить два последовательных медленных запроса:

1. **Запрос регистрации партнера**: `registerAndGetDepositLink()` - регистрирует пользователя в партнерской системе и получает ссылки для депозита/входа
2. **Запрос сохранения данных пользователя**: `saveUserX()` - сохраняет информацию о пользователе в нашей базе данных

Эти два запроса выполняются последовательно на стороне клиента, что замедляет процесс и создает ненужную нагрузку на клиентскую часть.

## Предлагаемое решение: Серверный оркестратор

Создать **серверный оркестратор**, который будет обрабатывать оба запроса на сервере после успешной верификации кода. Это позволит:

- Устранить необходимость двух медленных запросов со стороны клиента
- Объединить логику обработки в одном месте
- Улучшить производительность за счет серверного выполнения
- Повысить надежность за счет лучшей обработки ошибок на сервере

## Архитектурное решение

### 1. Новый маршрут оркестратора

Добавить новый маршрут в один из существующих серверов (предпочтительно в `users-regs-main-fasty` или создать отдельный оркестратор):

```
POST /api/users/orchestrate-registration
```

### 2. Логика оркестратора

1. Принимает данные после верификации (email, name, visitorId, и т.д.)
2. Выполняет запрос к партнерской системе (`https://reg.devuser.pro/register`)
3. Параллельно или сразу после успешного ответа от партнерской системы, сохраняет данные в собственной базе данных
4. Возвращает объединенный результат клиенту

### 3. Изменения в клиентской части

После успешной верификации кода, клиент будет делать **один** запрос к оркестратору вместо двух:

```javascript
// Вместо:
const depositUrl = await registerAndGetDepositLink(email, trafficParams);
await saveUserX(regData);

// Будет:
const result = await orchestrateRegistration(email, name, trafficParams, visitorId);
const depositUrl = result.depositUrl;
```

## Преимущества решения

1. **Уменьшение количества запросов от клиента** с 2 до 1
2. **Улучшенная производительность** за счет серверного выполнения и возможной параллельной обработки
3. **Лучшая обработка ошибок** на сервере
4. **Упрощение клиентской логики** - меньше кода на стороне клиента
5. **Централизованная логика** - вся обработка в одном месте
6. **Лучший контроль** над процессом регистрации

## Техническая реализация

### Вариант 1: Модификация существующего сервера

Можно добавить маршрут в `users-regs-main-fasty` сервер:

```typescript
// В файле routes.ts
fastify.post("/orchestrate-registration", async (request, reply) => {
  const { email, name, trafficParams, visitorId } = request.body;
  
  try {
    // Шаг 1: Регистрация в партнерской системе
    const partnerResult = await registerWithPartner({
      email,
      trafficParams,
      visitorId
    });
    
    if (!partnerResult.success) {
      return reply.code(400).send({ error: partnerResult.error });
    }
    
    // Шаг 2: Сохранение данных пользователя
    await saveUserData({
      email,
      name,
      visitorId,
      ...partnerResult,
      source: "orchestrated"
    });
    
    return reply.send({
      success: true,
      depositUrl: partnerResult.depositUrl,
      userData: partnerResult
    });
  } catch (error) {
    return reply.code(500).send({ error: "Orchestration failed" });
  }
});
```

### Вариант 2: Создание отдельного оркестратор-сервера

Создать отдельный микросервис, который будет координировать взаимодействие между сервисами:

```
Клиент → Оркестратор → Партнерская система
              ↓
         Система хранения данных
```

## Заключение

Реализация серверного оркестратора позволит значительно упростить клиентскую логику и улучшить производительность за счет объединения двух медленных запросов в один. Это также даст централизованный контроль над процессом регистрации и лучшую обработку ошибок.

Рекомендуется начать с модификации существующего `users-regs-main-fasty` сервера, добавив к нему функциональность оркестратора, так как он уже имеет инфраструктуру для работы с базой данных пользователей.